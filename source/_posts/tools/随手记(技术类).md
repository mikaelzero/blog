---
title: 随手记(技术类)
urlname: quick-note-technology
date: 2023/03/26
top: true
---

## 窗口

**一个应用程序窗口分别位于应用程序进程和 WindowManagerService 服务中的两个 Surface 对象有什么区别呢？**:
虽然它们都是用来操作位于 SurfaceFlinger 服务中的同一个 Layer 对象的，不过，它们的操作方式却不一样。具体来说，就是位于应用程序进程这一侧的 Surface 对象负责绘制应用程序窗口的 UI，即往应用程序窗口的图形缓冲区填充 UI 数据，而位于 WindowManagerService 服务这一侧的 Surface 对象负责设置应用程序窗口的属性，例如位置、大小等属性。这两种不同的操作方式分别是通过 C++ 层的 Surface 对象和 SurfaceControl 对象来完成的，因此，位于应用程序进程和 WindowManagerService 服务中的两个 Surface 对象的用法是有区别的。之所以会有这样的区别，是因为绘制应用程序窗口是独立的，由应用程序进程来完即可，而设置应用程序窗口的属性却需要全局考虑，即需要由 WindowManagerService 服务来统筹安排，例如，一个应用程序窗口的 Z 轴坐标大小要考虑它到的窗口类型以及它与系统中的其它窗口的关系。

**应用程序 Surface 创建**：
ViewRootImpl 类的成员函数 relayoutWindow 调用静态成员变量 sWindowSession 所描述的一个实现了 IWindowSession 接口的 Binder 代理对象的成员函数 relayout 来请求 WindowManagerService 服务对成员变量 mWindow 所描述的一个应用程序窗口的 UI 进行重新布局，同时，还会将成员变量 mSurface 所描述的一个 Surface 对象传递给 WindowManagerService 服务，以便 WindowManagerService 服务可以根据需要来重新创建一个绘图表面给成员变量 mWindow 所描述的一个应用程序窗口使用。

WindowManagerService 类的成员函数 relayoutWindow 接下来判断参数 client 所描述的一个应用程序窗口是否是可见的。一个窗口只有在可见的情况下，WindowManagerService 服务才会为它创建一个绘图表面。 一个窗口是否可见由以下两个条件决定：

1. 参数 viewVisibility 的值等于 View.VISIBLE，表示应用程序进程请求将它设置为可见的。
2. WindowState 对象 win 的成员变量 mAppToken 不等于 null，并且它所描述的一个 AppWindowToken 对象的成员变量 clientHidden 的值等于 false。这意味着参数 client 所描述的窗口是一个应用程序窗口，即一个 Activity 组件窗口，并且这个 Activity 组件当前是处于可见状态的。当一个 Activity 组件当前是处于不可见状态时，它的窗口就也必须是处于不可见状态。

假设参数 client 所描述的是一个应用程序窗口，并且这个应用程序窗口是可见的，那么 WindowManagerService 类的成员函数 relayoutWindow 接下来就会调用 WindowState 对象 win 的成员函数 createSurfaceLocked 来为它**创建一个绘图表面**。如果这个绘图表面能创建成功，那么 WindowManagerService 类的成员函数 relayoutWindow 就会将它的内容拷贝到输出参数 outSource 所描述的一个 Surface 对象去，以便可以将它返回给应用程序进程处理。另一方面，如果这个绘图表面不能创建成功，那么 WindowManagerService 类的成员函数 relayoutWindow 就会将输出参数 outSource 所描述的一个 Surface 对象的内容释放掉，以便应用程序进程知道该 Surface 对象所描述的绘图表面已经失效了。

**应用程序窗口的绘图表面的创建过程**:

这个函数定义在文件 frameworks/base/services/java/com/android/server/WindowManagerService.java 中。

在创建一个应用程序窗口的绘图表面之前，我们需要知道以下数据：

1. 应用程序窗口它所运行的应用程序进程的 PID。
2. 与应用程序窗口它所运行的应用程序进程所关联的一个 SurfaceSession 对象。
3. 应用程序窗口的标题。
4. 应用程序窗口的像素格式。
5. 应用程序窗口的宽度。
6. 应用程序窗口的高度。
7. 应用程序窗口的图形缓冲区属性标志。

Surface 类有三个成员变量 mSurfaceControl、mCanvas 和 mName，它们的类型分别是 int、Canvas 和 mName，其中，mSurfaceControl 保存的是在 C++ 层的一个 SurfaceControl 对象的地址值，mCanvas 用来描述一块类型为 CompatibleCanvas 的画布，mName 用来描述当前正在创建的一个绘图表面的名称。画布是真正用来绘制 UI 的地方，不过由于现在正在创建的绘图表面是在 WindowManagerService 服务这一侧使用的，而 WindowManagerService 服务不会去绘制应用程序窗口的 UI，它只会去设置应用程序窗口的属性，因此，这里创建的画布实际上没有什么作用，我们主要关注与成员变量 mSurfaceControl 所关联的 C++ 层的 SurfaceControl 对象是如何创建的。

Surface 类的构造函数是通过调用另外一个成员函数 init 来创建与成员变量 mSurfaceControl 所关联的 C++ 层的 SurfaceControl 对象的。Surface 类的成员函数 init 是一个 JNI 方法，它是由 C++ 层的函数 Surface_init 来实现的

## 参考链接

[那两年炼就的 Android 内功修养\_罗升阳的博客 - CSDN 博客](https://blog.csdn.net/Luoshengyang/article/details/8923485)