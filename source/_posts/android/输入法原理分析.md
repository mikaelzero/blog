---
title: 输入法原理分析
urlname: principle-analysis-of-input-method
date: 2023/03/08
tags:
  - android
  - framework
  - IMMS
  - IMS
  - 输入法
  - 软键盘
password: hello111111
---

## 需求场景

因为我们的应用是显示在虚拟屏上，所以当虚拟屏的输入框点击之后，输入法窗口会显示到主屏幕上，但是我们需要将它显示到另外一个虚拟屏上。

首先，先大致了解一下输入法的流程和术语。
、## 缩写解释

- IMS:输入法服务(Input Method Service)，一般是指一个具体的输入法对应的服务。
- IMMS:输入法服务管理器(Input Method Mananger Service)，属于系统进程的一部分，系统中只有一个该服务的实例。
- IMM:输入法管理器(Input Method Manager)，每个客户进程中包含一个该实例。
- IME:(Input Method Engine) , 泛指一个具体的输入法，包括其内部的 IM S 和各种其他 Binder 对象。

## 输入法显示流程

当用户在应用程序中需要输入文本时，Android 系统会自动弹出输入法窗口，该窗口位于应用程序的窗口之上。
输入法窗口会接收用户输入的文本，并将其传递给应用程序。为了实现这一点，输入法窗口使用了一个称为 InputConnection 的接口，该接口将输入的文本传递给应用程序。

在输入法窗口中，用户可以选择不同的输入法类型，例如 QWERTY 键盘、手写输入或语音输入等。输入法窗口会根据用户的选择来展示不同的输入界面。
Android 系统还提供了一个 InputMethodManager(IMM) 类来管理输入法窗口的显示和隐藏。通过该类，应用程序可以请求显示或隐藏输入法窗口，以便更好地管理用户的输入体验。
总的来说，Android 系统层面的输入法窗口原理是在应用程序窗口上方弹出一个悬浮窗口，该窗口可以接收用户输入的文本，并将其传递给应用程序。同时，Android 系统还提供了一些类和接口来管理输入法窗口的显示和隐藏，以便更好地管理用户的输入体验。

## 显示到虚拟屏上

既然输入法的窗口是一个 Dialog，那么我把这个 Dialog 在 addView 的时候人添加到我指定的 DisplayId 不就行了？

所以第一步就是先修改 SoftInputWindow(就是输入法窗口)，先创建一个虚拟屏，然后在 addView 的时候，修改 DisplayID 为固定的 1

## 焦点 View

第一个问题，mServedView 的问题。
在 showSoftInput 中会有一个验证

```java
 if (mServedView != view && (mServedView == null  || !mServedView.checkInputConnectionProxy(view))) {
      return false;
}
```

一般使用时，mServedView 和 view 是同一个对象，checkInputConnectionProxy 默认都是返回 false。

那么这两个 view 的逻辑是怎样的？

## 自动启动输入法

当点击了输入框之后，调用链是这样的：

```java
android.view.inputmethod.InputMethodManager.focusIn:1794
android.view.View.notifyFocusChangeToInputMethodManager:7951
android.view.View.onFocusChanged:7921
android.widget.TextView.onFocusChanged:10811
android.view.View.handleFocusGainInternal:7597
android.view.View.requestFocusNoSearch:12962
android.view.View.requestFocus:12936
android.view.View.onTouchEvent:15341
android.widget.TextView.onTouchEvent:10870
android.view.View.dispatchTouchEvent:13954
android.view.ViewGroup.dispatchTransformedTouchEvent:3060
android.view.ViewGroup.dispatchTouchEvent:2755
android.view.ViewGroup.dispatchTransformedTouchEvent:3060
com.android.internal.policy.DecorView.superDispatchTouchEvent:466
com.android.internal.policy.PhoneWindow.superDispatchTouchEvent:1849
```

InputMethodManager 的 focusIn 中，会将传递过来的 view(也就是输入框)赋值给 mNextServedView，另一个是判断 ViewRoot 中是否有 CHECK_FOCUS 消息，如果没有则发送一个，这会异步调用 InputMethodManager::checkFocus()函数

该函数中会先检查 served 视图是否变化。比如，如果用户在同一个 TextView 上连续点击时 ，也会执行到 checkFocus()函 数 ，但是由于视图没变化，因此该函数会立即返回 ， 检查的条件是对比 mServedView 和 mNextServedView。当第一次调用 checkFocus()函数时，这两个变量值不相同，而执行后，mServedView 被赋值为 mNextServedView.

## getFallbackInputMethodManagerIfNecessary

会验证当前的 display 和要显示的 display 他们的 ID 是否相同，（需要验证是否为系统创建？安全性？）
调用 IMM 的进程是哪个？如何确定的？
官方给的注释是

> 正如在 Bug 118341760 中所证明的那样，view.getViewRootImpl().getDisplayId()应该更可靠地确定给定视图正在与哪个显示器交互，而不是 view.getContext().getDisplayId()和 view.getContext().getSystemService()，这些方法可以很容易地被应用程序开发人员（或库作者）弄乱，通过创建不一致的 ContextWrapper 对象，重新分派这些方法到其他上下文，例如 ApplicationContext。

当客户端要显示输入法窗口时，会调用 IMM 的 showSoftInput()函数，该函数中则会调用 IMMS 的 同名函数。在 IM M S 中釆用的是异步机制，即先发送一个 MSG—SHOW_SOFT_INPUT 的消息，发送消 息时，调用了 IMMS 的内部函数 executeOrSendMessage()，该函数的参数使用 mCaller.obtainMessageIOO() 函数进行创建。mCaller 是一个 HandlerCaller 类。接下来就会执行到当前 IM S 中的同名函数 showSoftInput()中

addView 流程

```bash
---WindowManagerGlobal.addView()//创建了ViewRootImpl。addView的view是mDecor，ViewRootImpl中创建了mWindow(这里是一个IBinder,而非attach()中创建的)
----ViewRootImpl.setView()//openSession()创建了Session(IWindowSession的代理类)，view也是mDecor。mDecor传入到ViewRootImpl的mView
-----Session.addToDisplay()//通过Session进入system_server进程
------mService.addWindow()//进入WMS，执行addWindow()添加窗口
```

### 进度二

查看 dumps window 的时候，发现 displayid 并不是为 1，查看到 dumps 的代码是在 WindowState 的 dump 方法中，看看这个 getDisplayId 是在哪里赋值的

```java
    @Override
    public int getDisplayId() {
        final DisplayContent displayContent = getDisplayContent();
        if (displayContent == null) {
            return Display.INVALID_DISPLAY;
        }
        return displayContent.getDisplayId();
    }
```

这个 DisplayContent 是在 WMS 的 addWindow 时，通过 getDisplayContentOrCreate 获取

InputMethodManager 中的 mDisplayId 发现只是做验证作用

getDisplayInfoInternal 中会验证 info.hasAccess(callingUid) || isUidPresentOnDisplayInternal(callingUid, displayId)来是否返回 Display 信息