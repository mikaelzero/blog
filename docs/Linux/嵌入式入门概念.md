## 什么是嵌入式？

来源：https://zhuanlan.zhihu.com/p/514637070

嵌入式即嵌入式系统, IEEE（美国电气和电子工程师协会）对其定义是用于控制、监视或者辅助操作机器和设备的装置, 是一种专用的计算机系统. 国内普遍认同的嵌入式系统定义是以应用为中心, 以计算机技术为基础, 软硬件可裁剪, 适应应用系统对功能、可靠性、成本、体积、功耗等严格要求的专用计算机系统. 嵌入式是一个比较多学科综合的方向, 有很多细分的方向. 其实可以直接切入某个细分的领域, 比如单片机开发, Linux 应用开发, Linux 驱动开发.

![](https://picx.zhimg.com/80/v2-4ca0ed7a5012532ae8cb991bdbcd55bf_1440w.webp?source=d16d100b)

### 应用开发

推荐看《Unix 环境高级编程》, 这是基础.

### 驱动开发

对于底层知识的掌握要求比较高, 至少板机 Linux 的编译, 剪裁, 移植等内容. 可以根据具体硬件需求, 添加相应的驱动到系统中, 因为系统已经规定好相应的驱动框架, 因此需要了解各种内核子系统和各种类型的驱动. 比如字符设备驱动, 块设备驱动, 设备树的使用等等. 深入学习子系统也是一个难点, 可以帮忙更好地了解 Linux, 例如进程调度（SCHED）、内存管理（MM）、虚拟文件系统（VFS）、网络接口（NET）和进程间通信（IPC）. 比较推荐的学习资源, 宋宝华老师的 Linux 内核 4.0 驱动书籍, 韦东山老师的驱动视频, 互联网时代, 搜一下就有了. 总之, 技术在于积累.

### 非常规学习路线

在掌握部分基础知识之后, 也可以尝试这种学习路线, 按照项目的形式进行学习. 定一个目标项目, 例如；在 Linux 系统上实现一个程序, 如果非得和硬件沾边, 比如做一个人脸识别的门禁系统； 比如要在一个板子上移植 Linux 系统, 并添加驱动； 用单片机开发一个小项目, 完成软硬件的设计； 以上完全是三个不同的方向了, 因为每个人的具体情况都不相同, 可以根据自己的技术栈和兴趣爱好来做, 想不到做什么的, 找一些开源的项目, 自己复刻一下, 也是很好的. 有了目标之后, 将任务拆解, 这中间会遇到很多知识盲区, 会用到上面我提到过的很多知识, 这时候你就要去学习, 去吸收, 带着目的去学习和实践, 效果反而会更好.

## 能力矩阵

### 基础能力

- C++
- 数据结构
- linxu 系统、Shell 脚本、MakeFile/cmake/mk
- 文件 IO、多线程、并发、阻塞、同步、中断、网络
- 调试工具：gdb、gdbserver、tcpdump

## 行业能力

- 平台相关：海思//MTK/INXP/高通/瑞芯微等
- 系統相关：bootloader、kernel、文件系統, 定制、移植、开发与适配
- Android 相关：HAL. Services. Framework
- 驱动相关：驱动设备模型、GPIO. I2C. SPI. UART. WIFI. LCD. USB
- 物联网相关：TCP/IP、UDP. COAP. MQTT. HTTP
- 流媒体相关：RTMP. RTSP.
- 视顺编码：H264、H265.MJPEG
- 音领編码：PCM. AAC. G711
- 流媒体框架：FFMEPG、 G Streamer. WebRTC

## UART

通用异步收发传输器（Universal Asynchronous Receiver/Transmitter, 通常称为 UART）, 在 UART 通信中, 两个 UART 直接通信.

发送端的 UART 将来自控制设备（如 CPU）的并行数据转换为串行数据, 以串行方式将其发送到接收端的 UART, 然后由接收端的 UART 将串行数据转换为并行数据以用于接收设备的正常处理.

这里只需要两条线 RX/TX 即可在两个 UART 之间传输数据. 具体如下图所示；

![](https://pic3.zhimg.com/80/v2-6063ce74bdbad32a81df5aaa7392d596_1440w.webp)

## HAL 概念

Android 系统移植是指让 Android 操作系统在某一个特定硬件平台上运行, 使一个操作系统在特定硬件平台上运行的一个首要条件就是该操作系统支持硬件平台的 CPU 架构. Linux 内核本身已经支持很多常用的 CPU 架构（ARM、X86、PowerPC 等）, 因此, 将 Android 在不同的 CPU 架构之间移植并不用做过多的改动（有时仍然需要做一些调整）

Linux 内核本身已经支持很多常用的 CPU 架构（ARM、X86、PowerPC 等）, 因此, 将 Android 在不同的 CPU 架构之间移植并不用做过多的改动（有时仍然需要做一些调整）

也是普通的 Linux 程序库（.so 文件）, 只是 Android SDK 通过 HAL 直接访问 Linux 驱动. 也就是说, Android 并不像其他的 Linux 系统一样由应用程序直接访问驱动, 而是中间通过 HAL 隔了一层

因此, Android 移植的主要工作如下：

- 移植 Linux 驱动
- 移植 HAL

## uboot

- uboot 主要作用是用来启动操作系统内核
- uboot 还要负责部署整个计算机系统
- uboot 中还有操作 Flash 等板子上硬盘的驱动
- uboot 还得提供一个命令行界面供人来操作

## BSP

BSP, Board Support Package, 指板级支持包, 是构建嵌入式操作系统所需的引导程序(Bootload)、内核(Kernel)、根文件系统(Rootfs)和工具链 (Toolchain).
每种开发板的 BSP 都不一样, 并且这些源码都非常庞大

## SPI

## 内核文件系统

Linux 中设备驱动常见分类字符设备驱动、块设备驱动和网络设备驱动.
字符设备驱动是占用篇幅最大的一类驱动, 因为字符设备最多, 从最简单的点灯到 I2C、SPI、音频等都属于字符设备驱动的类型. 杂项设备是一种特殊的类似字符设备的设备.
块设备和网络设备驱动要比字符设备驱动复杂, 就是因为其复杂所以半导体厂商一般都给我们编写好了, 大多数情况下都是直接可以使用的.
所谓的块设备驱动就是存储器设备的驱动, 比如 EMMC、NAND、SD 卡和 U 盘等存储设备, 因为这些存储设备的特点是以存储块为基础, 因此叫做块设备.
网络设备驱动就更好理解了, 就是网络驱动, 不管是有线的还是无线的, 都属于网络设备驱动的范畴.
一个设备可以属于多种设备驱动类型, 比如 USB WIFI, 其使用 USB 接口, 所以属于字符设备, 但是其又能上网, 所以也属于网络设备驱动.

- 字符设备驱动居于文件, 以字节单位接受输入、返回输出 file_operations
- 块设备驱动以基于文件, 块单位接受输入、返回输出 block_device_operations
- 网络设备驱动居于网络套接字 net_device

字符驱动开发分为两步
一、向下把外设驱动起来
根据 datasheet 编写
二、向上提供外设访问接口
接口访问方式：

- devfs
- procfs
- sysfs

接口内部实现：

- 并发&竞争
- 阻塞&非阻塞访问
- 异步通知

### devfs

linux 下有专门的文件系统用来对设备进行管理, devfs 和 sysfs 就是其中两种. 在 2.6 内核以前一直使用的是 devfs, devfs 挂载于/dev 目录下, 提供了一种类似于文件的方法来管理位于/dev 目录下的所有设备, 我们知道/dev 目录下的每一个文件都对应的是一个设备. 应用通过对这些文件读写、控制以访问实际设备.

**devfs 的缺点：**

第一, 不确定的设备映射, 有时一个设备映射的设备文件可能不同, 例如我的 U 盘, 可能对应 sda 也可能对应 sdb.
第二, 没有足够的主/辅设备号, 当设备过多的时候, 这就是一个问题.
第三, 机制和策略都放到内核空间, 指定了第一个为/dev/module1 /dev/module2, 打开时加载驱动

### udev

正因为上述这些问题的存在, Linux2.6 后引入 udev, udev 是一种工具, 它能够根据系统中的硬件设备的状况动态更新设备文件, 包括设备文件的创建, 删除等

用户空间的工具 udev 使用 sysfs 提供的信息来实现所有 devfs 的功能的, 但不同的是 udev 运行在用户空间中, 而 devfs 却运行在内核空间, 而且 udev 不存在 devfs 那些先天的缺陷. 很显然, sysfs 将是未来发展的方向

设备文件通常放在/dev 目录下, 使用 udev 后,在/dev 下面只包含系统中真实存在的设备. 它与硬件平台无关的, 位于用户空间, 需要内核 sysfs 和 tmpfs 的支持, sysfs 为 udev 提供设备入口和 uevent 通道, tmpfs 为 udev 设备文件提供存放空间

在 android 中, 取代 udev 的是 vold,我们这里不去过多的讨论为什么 android 不继续使用 udev, 但要知道 vold 的机制和 udev 是一样 的, 理解了 udev,也就理解了 vold. android 一出生就没有遵守传统 linux 的许多标准, 当然也不能指望 udev 能很好的服务于 android. android 社区的选择是别起炉灶, 为 android 定做一套 udev,这就是 vold 了.

### sysfs

在 linux2.6 内核以后, 引入了一个新的文件系统 sysfs, 它挂载于/sys 目录下, 跟 devfs 一样它也是一个虚拟文件系统, 它把实际连接到系统上的设备和总线组织成一个分级的文件, 它们可以由用户空间存取, 向用户空间导出内核数据结构以及它们的属性

sysfs 分离 device_driver、device, 两者通过 bus_type 进行匹配, 一旦匹配成功, xxx_driver 的 probe 函数则被执行（xxx 为总线名, 如 platform pci i2c spi usb 等）

它是通过 kobject 子系统来建立这个信息的, 当一个 kobject 被创建的时候, 对应的文件和目录也就被创建了, 既然每个设备在 sysfs 中都有唯一对应的目录, 那么也就可以被用户空间读写了

总线、设备、驱动的各个 attribute 则落实为 sysfs 的一个目录, attribute 会伴随则 show 和 store 函数, 可被用于用户空间读取对应的 sysfs 文件

例如, 在引入 sysfs 之后的内核, 通过 cdev_init 和 cdev_add 添加字符设备, 通过 class_create 和 device_create 函数往 sys 文件系统中添加设备, udev 检测到/sys 目录的变动会根据变化在/dev 目录下创建对应的设备节点.

### procfs

操作系统运行时进程和内核信息存放在此.

### platform 设备驱动

从 Linux 2.6 起, 为了方便开发人员分离总线、设备、驱动这三个实体, 引入了一套新的驱动管理和注册机制：platform_bus、platform_device 和 platform_driver. Linux 中大部分的设备驱动, 都可以使用这套机制, 设备用 platform_device 表示, 驱动用 platform_driver 进行注册.
平台设备模型与传统的 device 和 driver 模型相比, 一个十分明显的优势在于平台设备模型将设备本身的资源注册进内核, 由内核统一管理. 这样提高了驱动和资源管理的独立性, 并且拥有较好的可移植性和安全性.

所谓的 platform 驱动并不是独立于字符设备驱动、块设备驱动和网络设备驱动之外的其他种类的驱动. platform 只是为了驱动的分离与分层而提出来的一种框架, 其驱动的具体实现还是需要字符设备驱动、块设备驱动或网络设备驱动

设备驱动模型侧重于内核对总线、设备和驱动的管理, 并向应用层暴露这些管理的信息.
而字符设备驱动、块设备驱动、网络设备驱动则侧重于设备驱动的功能实现

platform, I2C, SPI 等, 都是 BUS 的一种, 位于 sys/bus/下, I2C、SPI、USB 总线控制键本身也连接在 platform 总线上, 这部分是集成在芯片内部
platform_device(后期可用 DTS 代替)
platform_driver

设备号申请、注册、创建都需要用原来驱动函数, 只不过提供了一种框架, 例如通过 platform_device 可以适配多个设备.

### DTS

DTS（Device Tree Source）设备树源码.
在过去的 Linux 内核中, arch/arm/plat-xxxx 和 arch/arm/mach-xxx 充斥着大量垃圾代码, 这些代码只是在板卡厂商描述某块板卡的硬件细节, 但是对内核来说是无意义的, 在 Linux2.6 后, 引入了 DTS 设备树, 设备树提供了一种脚本方式, 可以板卡厂家把硬件资源相关的代码转换为这种更清晰的脚本管理.

### 用户空间访问驱动程序的方式

在 linux 系统中, 用户空间访问驱动程序一般有三种方式
1、通过 dev 设备文件访问
2、通过 procfs 接口访问
3、通过 sysfs 访问

### 通过设备文件“read/write/ioctl”的访问方式有几个明显的缺点.

- read/write 接口功能单一
- ioctl 虽然可以根据 cmd 参数实现多重功能, 但它们都无法直接在 shell/mash 脚本中被调用, 必须通过 C 语言方式访问
- ioctl 二进制数据接口存在大小端问题, 不同平台 CPU（32/64）不方便移植除了“设备文件”方式.

驱动程序还可以实现 procfs 虚拟文件系统接口, 提供给用户访问. procfs 访问驱动程序, 同样使用的是"read/open/ioctl"接口, 因此也存在“设备文件”方式中的类似问题.
另外也可以通过 sysfs 虚拟文件系统接口进行访问.

### device_attribute

所谓的 attibute, 主要用于在 sys 子系统中, 就是内核空间和用户空间进行信息交互的一种方法. 例如某个 driver 定义了一个变量, 却希望用户空间程序可以修改该变量, 以控制 driver 的运行行为, 那么就可以将该变量以 sysfs attribute 的形式开放出来.

```cpp
        //device_attribute  结构体中重要俩个函数 这里只用了.show .attr包括模式和名字
        static struct device_attribute xxxinfo = {
                .attr = {
                        .name = "xxxinfo",
                        .mode = 0444,
                },
                .show = xxxinfo_show,
        };
        char *drv_info = "I am xxx.ko";
        在drvinfo_show中采用sprintf()直接将信息输出. 用户层利用cat就可获取数据信息
        static ssize_t xxxinfo_show(struct device *dev,struct device_attribute * attr,char * buf)
        {
                return sprintf(buf,"driver info is %s\r\n", drv_info );
        }
        //在sys子系统下Class目录下创建一个XXX目录, 一般在驱动中的probe函数中进行
        myclass = class_create(THIS_MODULE, "XXX");
        if(IS_ERR(myclass))
        {
                printk("XXX class_create error\n");
                return 0;
        }
        //在XXX目录下创建一个yyy目录
        mydevice=device_create(myclass, NULL, chrdev_no, NULL, "yyy");

        //在yyy目录下创建xxxinfo节点, 通过读取节点即可获取信息版本
        if(device_create_file(mydevice, &drvinfo))
                printk(KERN_ALERT "Unable to create sysfs entry: '%s'\n",drvinfo.attr.name);
        else
                printk(KERN_ALERT "create sysfs file success\r\n");
        //最后在disconnect函数中使用device_remove_file删除
        device_remove_file(mydevice, &xxxinfo);
```

attribute 对应 sysfs 中的文件, sysfs 中的目录来自 bus_type、device_drive、device
内核中定义了一些快捷方式便于 Attribute 的创建工作

### 相关 API

```bash
传入主次设备号, 创建设备号
typedef u_long dev_t;
#define MKDEV(ma,mi)        ((ma)<<8 | (mi))
dev_t devid = MKDEV

查看系统设备号
cat proc/devices

静态申请设备编号
/*指定设备编号来静态注册一个字符设备*/
int register_chrdev_region(dev_t from, unsigned count, const char *name);　　
from: 注册的指定起始设备编号,比如:MKDEV(100, 0),表示起始主设备号100, 起始次设备号为0
count:需要连续注册的次设备编号个数,比如: 起始次设备号为0,count=100,表示0~99的次设备号都要绑定在同一个file_operations操作方法结构体上
*name:字符设备名称(/proc/devices);
当返回值小于0,表示注册失败

动态设备号申请
/*动态分配一个字符设备,注册成功并将分配到的主次设备号放入*dev里*/
int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count,const char *name);
*dev: 存放起始设备编号的指针,当注册成功, *dev就会等于分配到的起始设备编号,可以通过MAJOR()和MINNOR()函数来提取主次设备号
baseminor:次设备号基地址,也就是起始次设备号
count:需要连续注册的次设备编号个数,比如: 起始次设备号(baseminor)为0,baseminor=2,表示0~1的此设备号都要绑定在同一个file_operations操作方法结构体上
*name:字符设备名称
当返回值小于0,表示注册失败

注销字符设备
void unregister_chrdev_region(dev_t from, unsigned count);
from: 注销的指定起始设备编号,比如:MKDEV(100, 0),表示起始主设备号100, 起始次设备号为0
count:需要连续注销的次设备编号个数,比如: 起始次设备号为0,baseminor=100,表示注销掉0~99的次设备号
字符设备驱动结构体
#include <linux/cdev.h>
struct cdev {
  struct kobject kobj;       // 每个 cdev 都是一个 kobject
  struct module *owner;     // 指向实现驱动的模块
  const struct file_operations *ops;  // 操纵这个字符设备文件的方法
  struct list_head list;     // 与 cdev 对应的字符设备文件的 inode->i_devices 的链表头
  dev_t dev;               // 起始设备编号
  unsigned int count;     // 设备范围号大小
};

初始化字符设备驱动结构体
并将file_operations结构体放入cdev-> ops 里*/
void cdev_init(struct cdev *cdev, const struct file_operations *fops);
其中cdev结构体的成员,如下所示:
struct cdev {
       struct kobject    kobj;                   // 内嵌的kobject对象
       struct module   *owner;                   //所属模块
       const struct file_operations  *ops;     //操作方法结构体
       struct list_head  list;      　　　　　　//与 cdev 对应的字符设备文件的 inode->i_devices 的链表头
       dev_t dev;      　　　　　　　　　　　　　　//起始设备编号,可以通过MAJOR(),MINOR()来提取主次设备号
       unsigned int count;              　　//连续注册的次设备号个数
};

绑定设备号与字符设备驱动
/*将cdev结构体添加到系统中,并将dev(注册好的设备编号)放入cdev-> dev里,  count(次设备编号个数)放入cdev->count里*/
int cdev_add(struct cdev *p, dev_t dev, unsigned count);

将系统中的cdev结构体删除掉
void cdev_del(struct cdev *p);

创建一个设备类
#include <linux/device.h>
 cls=class_create(THIS_MODULE, "hello");
这个函数是实现创建类的操作. 它的本质是在/sys/class/目录创建一个 hello文件夹, 文件夹里面的内容仍然为空.

创建对应设备并将其注册到sysfs
 device_create(cls,0, MKDEV(major,0), 0, "hello0");   //对应hello_fops1操作结构体
这个函数用来给应用层mdev在/dev下创建设备节点. 它的本质是在/sys/module_test文件夹下, 创建各种文件, 文件的内容是为mdev创建设备节点所服务.
加载模块的时候, 用户空间中的udev会自动响应device_create(…)函数,
去/sysfs下寻找对应的类从而创建设备节点.
udev daemon就会自动在/dev下创建my_device设备文件.
device_destroy(cls, MKDEV(major,4));
class_destroy(cls);
```
