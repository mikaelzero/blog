在编译 Linux 驱动时, 必须选择与当前运行的 Linux 内核版本相同的 Linux 内核进行编译, 否则就无法安装 Linux 驱动.

## 最基础驱动

```cpp
#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/module.h>

static int hello_init(void)
{
    printk("hello world!\n");
    return 0;
}

static void hello_exit(void)
{
    printk("see you next time!\n");
    return;
}

module_init(hello_init);
module_exit(hello_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("embeded");
```

命令测试:

1. make 之后 push 到开发板中
2. insmod hello.ko
3. 通过 dmesg 可以查看到 hello world
4. rmmod hello 卸载驱动模块
5. 通过 dmesg 可以查看到 see you next time

## 写驱动程序的步骤

- 构造 file_operations 结构体
  - 在里面填充 open/read/write/ioctl 成员
- 注册 file_operations 结构体
  - int major = register_chrdev(0, "name", &fops);
- 入口函数：调用 regiister_chrdev
- 出口函数：调用 unregiister_chrdev
- 辅助信息：
  - class_create/class_destroy
  - device_create/device_destroy

```cpp
static const struct file_operations hello_drv = {
    .owner      = THIS_MODULE,
	.read		= hello_read,
	.write		= hello_write,
	.open		= hello_open,
    .release    = hello_release,
};

module_init(hello_init);
module_exit(hello_exit);
MODULE_LICENSE("GPL");
```

安装驱动以及测试

```bash
insmod hello.ko
mknod  /dev/xyz c 245 0

./hello_test /dev/xyz  hello_world

./hello_test /dev/xyz
```

上面的测试都是将 Linux 驱动编译成模块, 然后动态装载进行测试.
动态装载驱动模块不会随着 Android 系统的启动而自动装载, 因此 Android 系统每次启动都必须使用 insmod 或 modprobe 命令装载 Linux 驱动模块.
对于嵌入式系统（包括嵌入式 Android、嵌入式 Linux 等）一般都采用将 Linux 驱动编译进内核的方式. 这样做虽然没有动态装载灵活, 但 Linux 驱动会随着 Android 的启动而自动装载

## 测试驱动

1. 在 ubuntu 中测试
2. NDK 测试
3. APP 层测试, root 权限
4. 开发板测试
5. 编译进 Linux 内核测试

## APP 和驱动的交互方式

### 传输数据

APP 和驱动：

- copy_to_user
- copy_from_user

驱动和硬件：

- 各个子系统的函数
- 通过 ioremap 映射寄存器地址后, 直接访问寄存器

### APP 使用驱动的 4 种方式

驱动程序：提供能力, 不提供策略

- 非阻塞(查询)
- 阻塞(休眠-唤醒)
- poll(定个闹钟)
- 异步通知
